{
  "hash": "abd7b12fa8afed7d67907bb402a31fe2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Packet Traffic Learning\"\nsubtitle: \"Proposal\"\nauthor: \n  - name: \"The Anomalists - Joey Garcia, David Kyle\"\n    affiliations:\n      - name: \"College of Information Science, University of Arizona\"\ndescription: \"Project description: Our project aims to develop a predictive model to detect anomalous network behavior using packet-level and statistical features derived from network traffic. With machine learning models, we aim to accurately classify and predict network anomalies, which is essential for intrusion detection, network security monitoring, and incident response automation.\"\nformat:\n  html:\n    code-tools: true\n    code-overflow: wrap\n    code-line-numbers: true\n    embed-resources: true\neditor: visual\ncode-annotations: hover\nexecute:\n  warning: false\njupyter: python3\n---\n\n::: {#load-pkgs .cell message='false' execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy import stats # for analysis plan\n```\n:::\n\n\n## Dataset\n\n::: {#load-dataset .cell message='false' execution_count=2}\n``` {.python .cell-code}\nnetwork_traffic_train = pd.read_csv('data/KDDTrain+.txt')\nnetwork_traffic_test = pd.read_csv('data/KDDTest+.txt')\n\ndf_train = network_traffic_train.copy()\ndf_test = network_traffic_test.copy()\n\n'''\nColumns recieved from kaggle project \nhttps://www.kaggle.com/code/faizankhandeshmukh/intrusion-detection-system\n\n'''\n\n# Define the list of column names based on the NSL-KDD dataset description\ncolumns = [\n    'duration', 'protocol_type', 'service', 'flag', 'src_bytes', 'dst_bytes',\n    'land', 'wrong_fragment', 'urgent', 'hot', 'num_failed_logins',\n    'logged_in', 'num_compromised', 'root_shell', 'su_attempted', 'num_root',\n    'num_file_creations', 'num_shells', 'num_access_files', 'num_outbound_cmds',\n    'is_host_login', 'is_guest_login', 'count', 'srv_count', 'serror_rate',\n    'srv_serror_rate', 'rerror_rate', 'srv_rerror_rate', 'same_srv_rate',\n    'diff_srv_rate', 'srv_diff_host_rate', 'dst_host_count',\n    'dst_host_srv_count', 'dst_host_same_srv_rate', 'dst_host_diff_srv_rate',\n    'dst_host_same_src_port_rate', 'dst_host_srv_diff_host_rate',\n    'dst_host_serror_rate', 'dst_host_srv_serror_rate', 'dst_host_rerror_rate',\n    'dst_host_srv_rerror_rate', 'attack', 'level'\n]\n\n# Assign the column names to the dataframe\ndf_train.columns = columns\ndf_test.columns = columns\n\n\nprint('Shapes (train, test):', df_train.shape, df_test.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShapes (train, test): (125972, 43) (22543, 43)\n```\n:::\n:::\n\n\nWe are using a training and testing dataset of network intrusion detection from [NSL-KDD from Kaggle](https://www.kaggle.com/datasets/hassan06/nslkdd/data?select=KDDTrain1.jpg). The intrusion detection network traffic training dataset contains **125,972 rows** and **43 columns**, and **22,543 rows** and **43 columns** in the test dataset.\n\nThe `attack` field indicates normal or anomalous (multi-class) observations which allows us to use learning approaches for classifying anomalous network activity. A new binary classification feature, `is_anomalous`, will be added to indicate if the network connection was anomalous or not. This will be the target field for the project.\n\nWe chose this dataset because it provides a rich and realistic representation of network traffic data. The presence of labeled data allows us to train and evaluate supervised models; the diversity and volume of traffic patterns make it well-suited for exploring unsupervised anomaly detection techniques as well. This balance between complexity and feature richness aligns well with our research questions and modeling goals.\n\n## Questions\n\nQ1. Using supervised machine learning models such as Long Short-Term Memory (LSTM) and Support Vector Machines (SVMs), can we accurately calssify network traffic as normal and anomalous based on labeled data? How do their performances compare in terms of accuracy, precision, recall, and F1-score?\n\nQ2. Can unsupervised learning methods such as K-Means Clustering and Density-Based Clustering (DBSCAN) detect anomalous patterns in network traffic without using labeled data?\n\nSummary. How do the supervised and unsupervised approaches compare?\n\n## Dataset Analysis\n\n### Variables\n\n| Column Name | Data Type | Description |\n|---------------|---------------|-------------------------------------------|\n| `duration` | int64 | Length (in seconds) of the connection. |\n| `protocol_type` | object | Protocol used (e.g., tcp, udp, icmp). |\n| `service` | object | Network service on the destination (e.g., http, telnet). |\n| `flag` | object | Status flag of the connection. |\n| `src_bytes` | int64 | Number of data bytes sent from source to destination. |\n| `dst_bytes` | int64 | Number of data bytes sent from destination to source. |\n| `land` | int64 | 1 if connection is from/to the same host/port; 0 otherwise. |\n| `wrong_fragment` | int64 | Number of wrong fragments. |\n| `urgent` | int64 | Number of urgent packets. |\n| `hot` | int64 | Number of \"hot\" indicators. |\n| `num_failed_logins` | int64 | Number of failed login attempts. |\n| `logged_in` | int64 | 1 if successfully logged in; 0 otherwise. |\n| `num_compromised` | int64 | Number of compromised conditions. |\n| `root_shell` | int64 | 1 if root shell is obtained; 0 otherwise. |\n| `su_attempted` | int64 | 1 if \"su root\" command attempted; 0 otherwise. |\n| `num_root` | int64 | Number of \"root\" accesses. |\n| `num_file_creations` | int64 | Number of file creation operations. |\n| `num_shells` | int64 | Number of shell prompts invoked. |\n| `num_access_files` | int64 | Number of accesses to control files. |\n| `num_outbound_cmds` | int64 | Number of outbound commands (always 0 in KDD99). |\n| `is_host_login` | int64 | 1 if login is to a host account; 0 otherwise. |\n| `is_guest_login` | int64 | 1 if login is to a guest account; 0 otherwise. |\n| `count` | int64 | Number of connections to the same host in the past 2 seconds. |\n| `srv_count` | int64 | Number of connections to the same service in the past 2 seconds. |\n| `serror_rate` | float64 | \\% of connections with SYN errors. |\n| `srv_serror_rate` | float64 | \\% of connections to the same service with SYN errors. |\n| `rerror_rate` | float64 | \\% of connections with REJ errors. |\n| `srv_rerror_rate` | float64 | \\% of connections to the same service with REJ errors. |\n| `same_srv_rate` | float64 | \\% of connections to the same service. |\n| `diff_srv_rate` | float64 | \\% of connections to different services. |\n| `srv_diff_host_rate` | float64 | \\% of connections to different hosts on the same service. |\n| `dst_host_count` | int64 | Number of connections to the destination host. |\n| `dst_host_srv_count` | int64 | Number of connections to the destination host and service. |\n| `dst_host_same_srv_rate` | float64 | \\% of connections to the same service on the destination host. |\n| `dst_host_diff_srv_rate` | float64 | \\% of connections to different services on the destination host. |\n| `dst_host_same_src_port_rate` | float64 | \\% of connections from the same source port. |\n| `dst_host_srv_diff_host_rate` | float64 | \\% of connections to the same service from different hosts. |\n| `dst_host_serror_rate` | float64 | \\% of connections with SYN errors to the destination host. |\n| `dst_host_srv_serror_rate` | float64 | \\% of connections with SYN errors to the destination service. |\n| `dst_host_rerror_rate` | float64 | \\% of connections with REJ errors to the destination host. |\n| `dst_host_srv_rerror_rate` | float64 | \\% of connections with REJ errors to the destination service. |\n| `attack` | object | Label indicating the type of attack or \"normal\". |\n| `level` | int64 | Severity or confidence score of the attack (if available). |\n\n### Exploratory Data Analysis\n\nWe take a quick look at the training data to see if there are any obvious imbalances.\n\n::: {#exploratory-data-analysis .cell execution_count=3}\n``` {.python .cell-code}\nprint(\"Shape:\", df_train.shape)\nprint(\"Missing values:\", df_train.isna().sum().sum())\nprint(\"Duplicates:\", df_train.duplicated().sum())\nprint(\"Unique attack labels:\", df_train['attack'].nunique())\nprint(\"Attack label distribution:\\n\", df_train['attack'].value_counts().head(5))\n\n# Show types and non-null counts\ndf_train.info(verbose=False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape: (125972, 43)\nMissing values: 0\nDuplicates: 0\nUnique attack labels: 23\nAttack label distribution:\n attack\nnormal       67342\nneptune      41214\nsatan         3633\nipsweep       3599\nportsweep     2931\nName: count, dtype: int64\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 125972 entries, 0 to 125971\nColumns: 43 entries, duration to level\ndtypes: float64(15), int64(24), object(4)\nmemory usage: 41.3+ MB\n```\n:::\n:::\n\n\nThe brief look at the data is positive. There are plenty of data points and features, depending on time speeds for fitting models, we may decrease our sample size because hyper parameter using GridSearchCV training may be time intensive. In the data there are no missing values, and the glimpse of the `attack` column provides insight into why we want to collapse it into a binary column.\n\n### Normal vs Anomalous Traffic\n\nFirst, look at the amount of normal v. anomalous data.\n\n::: {#cell-class-distribution .cell message='false' execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](proposal_files/figure-html/class-distribution-output-1.png){#class-distribution width=944 height=367}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nattack\nnormal             67342\nneptune            41214\nsatan               3633\nipsweep             3599\nportsweep           2931\nsmurf               2646\nnmap                1493\nback                 956\nteardrop             892\nwarezclient          890\npod                  201\nguess_passwd          53\nbuffer_overflow       30\nwarezmaster           20\nland                  18\nimap                  11\nrootkit               10\nloadmodule             9\nftp_write              8\nmultihop               7\nphf                    4\nperl                   3\nspy                    2\nName: count, dtype: int64\n```\n:::\n:::\n\n\nThe plot provides an idea of the specific attack types expressesd in the data. The plot communicates why it makes sense to group all non-normal traffic together.\n\nWe feature engineer a new column, `is_anomalous`, this contains 0 if the connection is normal and 1 if the connection is not normal.\n\n::: {#feature-engineering .cell execution_count=5}\n``` {.python .cell-code}\n# create binary target column: 1 = attack, 0 = normal\n\ndf_train['is_anomalous'] = df_train['attack'].apply(\n  lambda x: 0 if x == 'normal' else 1)\n```\n:::\n\n\nExamine the new column, `is_anaomalous`, to get an idea of the target frequency.\n\n::: {#countplot-anomalous .cell message='false' execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](proposal_files/figure-html/countplot-anomalous-output-1.png){#countplot-anomalous-1 width=944 height=559}\n:::\n\n::: {#countplot-anomalous-2 .cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n      <th>Percentage</th>\n    </tr>\n    <tr>\n      <th>is_anomalous</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Normal</th>\n      <td>67342</td>\n      <td>53.46</td>\n    </tr>\n    <tr>\n      <th>Attack</th>\n      <td>58630</td>\n      <td>46.54</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `is_anomalous` classification target shows a near-even class distribution indicating the the dataset is well balanced. There should be no need for resampling or class weighting to correct the set. It appears this dataset will be a good candidate for learning models.\n\n## Analysis plan\n\n### Problem Introduction\n\nThe project is to build and evaluate models capable of detecting anomalous network traffic based on connection-level features from the NSL-KDD dataset. The problem is framed as a binary classification task, where each record is labeled as either normal or anomalous. This has real-world applications in intrusion detection systems and network security monitoring.\n\nThe project will explore both supervised and unsupervised machine learning techniques to assess their effectiveness in identifying attacks from structured network traffic data.\n\n### Feature Engineering Strategy\n\nTo ensure a fair and consistent comparison, we will apply the same feature engineering pipeline to both supervised and unsupervised models. All features will be assigned appropriate column names based on the NSL-KDD documentation. Categorical variables such as protocol_type, service, and flag will be one-hot encoded, and low-variance or non-informative columns will be removed. Numeric features will be standardized using a scaler to normalize their ranges.\n\nFor supervised models, these engineered features will be used alongside the binary target is_anomalous. For unsupervised models, the same processed features will be used without labels, allowing the models to explore underlying structure or detect anomalous patterns. This consistent preprocessing ensures that differences in performance can be attributed to the modeling approaches rather than inconsistencies in data preparation.\n\n### Dimensionality Reduction\n\nOur dataset currently has over 40 features, we will apply a combination of feature reduction techniques such as Principal Component Analysis (PCA), Linear Discriminant Analysis (LDA), or even use the Random Forest Classifier feature importance attribute. We'll experiment to determine the most optimal feature subset for our classification task.\n\n### Q1. Supervised Learning\n\nFor the supervised learning portion of the project, we will train and evaluate models using the labeled NSL-KDD dataset to classify network traffic as normal or anomalous. Specifically, we will implement and compare a Long Short-Term Memory (LSTM) neural network and a Support Vector Machine (SVM). These models will be trained on the same feature-engineered data, using the is_anomalous column as the target. Model performance will be assessed using standard classification metrics, including accuracy, precision, recall, F1-score, and ROC AUC.\n\n### Q2. Unsupervised Learning\n\nFor the unsupervised learning portion of the project, we will explore clustering-based approaches to detect anomalies in network traffic without relying on labeled data. We plan to experiment with techniques such as K-Means and DBSCAN to group similar observations and identify outliers that may correspond to attacks. After clustering, we will evaluate how well the resulting groupings align with the true labels using appropriate metrics for unsupervised learning. This will help us assess the potential of unsupervised models to detect anomalous behavior in the absence of supervision.\n\n### Summary Comparison\n\nTo compare the supervised and unsupervised approaches, we will evaluate their ability to correctly identify anomalous traffic using relevant metrics for each method. We will also consider practical factors such as interpretability, scalability, and the need for labeled data.\n\n### Project Timeline\n\n| Task Name | Status | Due | Priority | Summary |\n|-------------|-------------|-------------|-------------|-----------------------|\n| Dataset exploration | In Progress | Week 1 | High | Load the dataset, inspect features, handle any preprocessing needs. |\n| Define research questions | Complete | Week 1 | High | Clarify goals for supervised and unsupervised anomaly detection. |\n| Supervised model development | Not Started | Week 2 | High | Train models like Random Forest, Logistic Regression, and XGBoost. |\n| Evaluation of supervised models | Not Started | Week 3 | High | Use accuracy, precision, recall, F₁, and ROC-AUC to assess performance. |\n| Unsupervised model development | Not Started | Week 3 | Medium | Explore methods like Isolation Forest and clustering. |\n| Evaluation of unsupervised models | Not Started | Week 4 | Medium | Compare anomaly scores to labeled data using precision-recall metrics. |\n| Comparative analysis | Not Started | Week 4 | High | Analyze strengths and weaknesses of both approaches. |\n| Final report & presentation | Not Started | Week 5 | High | Compile results, figures, and discussion into final deliverables. |\n\n",
    "supporting": [
      "proposal_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}